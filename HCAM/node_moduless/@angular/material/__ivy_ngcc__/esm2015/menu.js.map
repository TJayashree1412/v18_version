{"version":3,"sources":["C:/Users/VarshaRanga/angular/sample/demo/node_modules/@angular/material/esm2015/menu.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+DC,4HAKC;;;;;;;;;;;;;;;;;;kCASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgPD,gFAoBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4VD,kCAgBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgfD,sVAcC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAoBA;;;;;;;;;;;;;;;CAOD;;;;;;;;;;;;;;;;;;;;;;;;;0BAaC","file":"menu.js","sourcesContent":["/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport { Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, InjectionToken, ChangeDetectionStrategy, Component, ElementRef, ViewEncapsulation, Optional, ContentChild, ContentChildren, EventEmitter, Input, NgZone, Output, ViewChild, Self, NgModule } from '@angular/core';\r\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { Subject, merge, Subscription, asapScheduler, of } from 'rxjs';\r\nimport { trigger, state, style, animate, transition, query, group } from '@angular/animations';\r\nimport { FocusMonitor, FocusKeyManager, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\r\nimport { mixinDisabled, mixinDisableRipple, MatCommonModule, MatRippleModule } from '@angular/material/core';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { ESCAPE, LEFT_ARROW, RIGHT_ARROW, DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';\r\nimport { startWith, switchMap, take, delay, filter, takeUntil } from 'rxjs/operators';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n/**\r\n * Menu content that will be rendered lazily once the menu is opened.\r\n */\r\nclass MatMenuContent {\r\n    /**\r\n     * @param {?} _template\r\n     * @param {?} _componentFactoryResolver\r\n     * @param {?} _appRef\r\n     * @param {?} _injector\r\n     * @param {?} _viewContainerRef\r\n     * @param {?} _document\r\n     */\r\n    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {\r\n        this._template = _template;\r\n        this._componentFactoryResolver = _componentFactoryResolver;\r\n        this._appRef = _appRef;\r\n        this._injector = _injector;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._document = _document;\r\n        /**\r\n         * Emits when the menu content has been attached.\r\n         */\r\n        this._attached = new Subject();\r\n    }\r\n    /**\r\n     * Attaches the content with a particular context.\r\n     * \\@docs-private\r\n     * @param {?=} context\r\n     * @return {?}\r\n     */\r\n    attach(context = {}) {\r\n        if (!this._portal) {\r\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\r\n        }\r\n        this.detach();\r\n        if (!this._outlet) {\r\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\r\n        }\r\n        /** @type {?} */\r\n        const element = this._template.elementRef.nativeElement; /** @type {?} */\r\n        ((\r\n        // Because we support opening the same menu from different triggers (which in turn have their\r\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\r\n        // risk it staying attached to a pane that's no longer in the DOM.\r\n        element.parentNode)).insertBefore(this._outlet.outletElement, element);\r\n        this._portal.attach(this._outlet, context);\r\n        this._attached.next();\r\n    }\r\n    /**\r\n     * Detaches the content.\r\n     * \\@docs-private\r\n     * @return {?}\r\n     */\r\n    detach() {\r\n        if (this._portal.isAttached) {\r\n            this._portal.detach();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._outlet) {\r\n            this._outlet.dispose();\r\n        }\r\n    }\r\n}\r\nMatMenuContent.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: 'ng-template[matMenuContent]'\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatMenuContent.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: ComponentFactoryResolver },\r\n    { type: ApplicationRef },\r\n    { type: Injector },\r\n    { type: ViewContainerRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n/** *\r\n * Animations used by the mat-menu component.\r\n * Animation duration and timing values are based on:\r\n * https://material.io/guidelines/components/menus.html#menus-usage\r\n * \\@docs-private\r\n  @type {?} */\r\nconst matMenuAnimations = {\r\n    /**\r\n       * This animation controls the menu panel's entry and exit from the page.\r\n       *\r\n       * When the menu panel is added to the DOM, it scales in and fades in its border.\r\n       *\r\n       * When the menu panel is removed from the DOM, it simply fades out after a brief\r\n       * delay to display the ripple.\r\n       */\r\n    transformMenu: trigger('transformMenu', [\r\n        state('void', style({\r\n            opacity: 0,\r\n            transform: 'scale(0.8)'\r\n        })),\r\n        transition('void => enter', group([\r\n            query('.mat-menu-content', animate('100ms linear', style({ opacity: 1 }))),\r\n            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),\r\n        ])),\r\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))\r\n    ]),\r\n    /**\r\n       * This animation fades in the background color and content of the menu panel\r\n       * after its containing element is scaled in.\r\n       */\r\n    fadeInItems: trigger('fadeInItems', [\r\n        // TODO(crisbeto): this is inside the `transformMenu`\r\n        // now. Remove next time we do breaking changes.\r\n        state('showing', style({ opacity: 1 })),\r\n        transition('void => *', [\r\n            style({ opacity: 0 }),\r\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\r\n        ])\r\n    ])\r\n};\r\n/** *\r\n * @deprecated\r\n * \\@breaking-change 8.0.0\r\n * \\@docs-private\r\n  @type {?} */\r\nconst fadeInItems = matMenuAnimations.fadeInItems;\r\n/** *\r\n * @deprecated\r\n * \\@breaking-change 8.0.0\r\n * \\@docs-private\r\n  @type {?} */\r\nconst transformMenu = matMenuAnimations.transformMenu;\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction throwMatMenuMissingError() {\r\n    throw Error(`matMenuTriggerFor: must pass in an mat-menu instance.\r\n\r\n    Example:\r\n      <mat-menu #menu=\"matMenu\"></mat-menu>\r\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\r\n}\r\n/**\r\n * Throws an exception for the case when menu's x-position value isn't valid.\r\n * In other words, it doesn't match 'before' or 'after'.\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction throwMatMenuInvalidPositionX() {\r\n    throw Error(`xPosition value must be either 'before' or after'.\r\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\r\n}\r\n/**\r\n * Throws an exception for the case when menu's y-position value isn't valid.\r\n * In other words, it doesn't match 'above' or 'below'.\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction throwMatMenuInvalidPositionY() {\r\n    throw Error(`yPosition value must be either 'above' or below'.\r\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\r\n}\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n/** *\r\n * Injection token used to provide the parent menu to menu-specific components.\r\n * \\@docs-private\r\n  @type {?} */\r\nconst MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n/**\r\n * \\@docs-private\r\n */\r\nclass MatMenuItemBase {\r\n}\r\n/** @type {?} */\r\nconst _MatMenuItemMixinBase = mixinDisableRipple(mixinDisabled(MatMenuItemBase));\r\n/**\r\n * This directive is intended to be used inside an mat-menu tag.\r\n * It exists mostly to set the role attribute.\r\n */\r\nclass MatMenuItem extends _MatMenuItemMixinBase {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?=} document\r\n     * @param {?=} _focusMonitor\r\n     * @param {?=} _parentMenu\r\n     */\r\n    constructor(_elementRef, document, _focusMonitor, _parentMenu) {\r\n        // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\r\n        super();\r\n        this._elementRef = _elementRef;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._parentMenu = _parentMenu;\r\n        /**\r\n         * Stream that emits when the menu item is hovered.\r\n         */\r\n        this._hovered = new Subject();\r\n        /**\r\n         * Whether the menu item is highlighted.\r\n         */\r\n        this._highlighted = false;\r\n        /**\r\n         * Whether the menu item acts as a trigger for a sub-menu.\r\n         */\r\n        this._triggersSubmenu = false;\r\n        if (_focusMonitor) {\r\n            // Start monitoring the element so it gets the appropriate focused classes. We want\r\n            // to show the focus style for menu items only when the focus was not caused by a\r\n            // mouse or touch interaction.\r\n            _focusMonitor.monitor(this._elementRef, false);\r\n        }\r\n        if (_parentMenu && _parentMenu.addItem) {\r\n            _parentMenu.addItem(this);\r\n        }\r\n        this._document = document;\r\n    }\r\n    /**\r\n     * Focuses the menu item.\r\n     * @param {?=} origin\r\n     * @return {?}\r\n     */\r\n    focus(origin = 'program') {\r\n        if (this._focusMonitor) {\r\n            this._focusMonitor.focusVia(this._getHostElement(), origin);\r\n        }\r\n        else {\r\n            this._getHostElement().focus();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._focusMonitor) {\r\n            this._focusMonitor.stopMonitoring(this._elementRef);\r\n        }\r\n        if (this._parentMenu && this._parentMenu.removeItem) {\r\n            this._parentMenu.removeItem(this);\r\n        }\r\n        this._hovered.complete();\r\n    }\r\n    /**\r\n     * Used to set the `tabindex`.\r\n     * @return {?}\r\n     */\r\n    _getTabIndex() {\r\n        return this.disabled ? '-1' : '0';\r\n    }\r\n    /**\r\n     * Returns the host DOM element.\r\n     * @return {?}\r\n     */\r\n    _getHostElement() {\r\n        return this._elementRef.nativeElement;\r\n    }\r\n    /**\r\n     * Prevents the default element actions if it is disabled.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _checkDisabled(event) {\r\n        if (this.disabled) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n        }\r\n    }\r\n    /**\r\n     * Emits to the hover stream.\r\n     * @return {?}\r\n     */\r\n    _handleMouseEnter() {\r\n        this._hovered.next(this);\r\n    }\r\n    /**\r\n     * Gets the label to be used when determining whether the option should be focused.\r\n     * @return {?}\r\n     */\r\n    getLabel() {\r\n        /** @type {?} */\r\n        const element = this._elementRef.nativeElement;\r\n        /** @type {?} */\r\n        const textNodeType = this._document ? this._document.TEXT_NODE : 3;\r\n        /** @type {?} */\r\n        let output = '';\r\n        if (element.childNodes) {\r\n            /** @type {?} */\r\n            const length = element.childNodes.length;\r\n            // Go through all the top-level text nodes and extract their text.\r\n            // We skip anything that's not a text node to prevent the text from\r\n            // being thrown off by something like an icon.\r\n            for (let i = 0; i < length; i++) {\r\n                if (element.childNodes[i].nodeType === textNodeType) {\r\n                    output += element.childNodes[i].textContent;\r\n                }\r\n            }\r\n        }\r\n        return output.trim();\r\n    }\r\n}\r\nMatMenuItem.decorators = [\r\n    { type: Component, args: [{selector: '[mat-menu-item]',\r\n                exportAs: 'matMenuItem',\r\n                inputs: ['disabled', 'disableRipple'],\r\n                host: {\r\n                    'role': 'menuitem',\r\n                    'class': 'mat-menu-item',\r\n                    '[class.mat-menu-item-highlighted]': '_highlighted',\r\n                    '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\r\n                    '[attr.tabindex]': '_getTabIndex()',\r\n                    '[attr.aria-disabled]': 'disabled.toString()',\r\n                    '[attr.disabled]': 'disabled || null',\r\n                    '(click)': '_checkDisabled($event)',\r\n                    '(mouseenter)': '_handleMouseEnter()',\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                template: \"<ng-content></ng-content><div class=\\\"mat-menu-ripple\\\" matRipple [matRippleDisabled]=\\\"disableRipple || disabled\\\" [matRippleTrigger]=\\\"_getHostElement()\\\"></div>\",\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatMenuItem.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: FocusMonitor },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] }\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n/** *\r\n * Injection token to be used to override the default options for `mat-menu`.\r\n  @type {?} */\r\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\r\n});\r\n/**\r\n * \\@docs-private\r\n * @return {?}\r\n */\r\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\r\n    return {\r\n        overlapTrigger: false,\r\n        xPosition: 'after',\r\n        yPosition: 'below',\r\n        backdropClass: 'cdk-overlay-transparent-backdrop',\r\n    };\r\n}\r\n/** *\r\n * Start elevation for the menu panel.\r\n * \\@docs-private\r\n  @type {?} */\r\nconst MAT_MENU_BASE_ELEVATION = 4;\r\nclass MatMenu {\r\n    /**\r\n     * @param {?} _elementRef\r\n     * @param {?} _ngZone\r\n     * @param {?} _defaultOptions\r\n     */\r\n    constructor(_elementRef, _ngZone, _defaultOptions) {\r\n        this._elementRef = _elementRef;\r\n        this._ngZone = _ngZone;\r\n        this._defaultOptions = _defaultOptions;\r\n        this._xPosition = this._defaultOptions.xPosition;\r\n        this._yPosition = this._defaultOptions.yPosition;\r\n        /**\r\n         * Menu items inside the current menu.\r\n         */\r\n        this._items = [];\r\n        /**\r\n         * Emits whenever the amount of menu items changes.\r\n         */\r\n        this._itemChanges = new Subject();\r\n        /**\r\n         * Subscription to tab events on the menu panel\r\n         */\r\n        this._tabSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Config object to be passed into the menu's ngClass\r\n         */\r\n        this._classList = {};\r\n        /**\r\n         * Current state of the panel animation.\r\n         */\r\n        this._panelAnimationState = 'void';\r\n        /**\r\n         * Emits whenever an animation on the menu completes.\r\n         */\r\n        this._animationDone = new Subject();\r\n        /**\r\n         * Class to be added to the backdrop element.\r\n         */\r\n        this.backdropClass = this._defaultOptions.backdropClass;\r\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\r\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\r\n        /**\r\n         * Event emitted when the menu is closed.\r\n         */\r\n        this.closed = new EventEmitter();\r\n        /**\r\n         * Event emitted when the menu is closed.\r\n         * @deprecated Switch to `closed` instead\r\n         * \\@breaking-change 8.0.0\r\n         */\r\n        this.close = this.closed;\r\n    }\r\n    /**\r\n     * Position of the menu in the X axis.\r\n     * @return {?}\r\n     */\r\n    get xPosition() { return this._xPosition; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set xPosition(value) {\r\n        if (value !== 'before' && value !== 'after') {\r\n            throwMatMenuInvalidPositionX();\r\n        }\r\n        this._xPosition = value;\r\n        this.setPositionClasses();\r\n    }\r\n    /**\r\n     * Position of the menu in the Y axis.\r\n     * @return {?}\r\n     */\r\n    get yPosition() { return this._yPosition; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set yPosition(value) {\r\n        if (value !== 'above' && value !== 'below') {\r\n            throwMatMenuInvalidPositionY();\r\n        }\r\n        this._yPosition = value;\r\n        this.setPositionClasses();\r\n    }\r\n    /**\r\n     * Whether the menu should overlap its trigger.\r\n     * @return {?}\r\n     */\r\n    get overlapTrigger() { return this._overlapTrigger; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set overlapTrigger(value) {\r\n        this._overlapTrigger = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * Whether the menu has a backdrop.\r\n     * @return {?}\r\n     */\r\n    get hasBackdrop() { return this._hasBackdrop; }\r\n    /**\r\n     * @param {?} value\r\n     * @return {?}\r\n     */\r\n    set hasBackdrop(value) {\r\n        this._hasBackdrop = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * This method takes classes set on the host mat-menu element and applies them on the\r\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\r\n     * to style the containing menu from outside the component.\r\n     * @param {?} classes list of class names\r\n     * @return {?}\r\n     */\r\n    set panelClass(classes) {\r\n        if (classes && classes.length) {\r\n            this._classList = classes.split(' ').reduce((obj, className) => {\r\n                obj[className] = true;\r\n                return obj;\r\n            }, {});\r\n            this._elementRef.nativeElement.className = '';\r\n        }\r\n    }\r\n    /**\r\n     * This method takes classes set on the host mat-menu element and applies them on the\r\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\r\n     * to style the containing menu from outside the component.\r\n     * @deprecated Use `panelClass` instead.\r\n     * \\@breaking-change 8.0.0\r\n     * @return {?}\r\n     */\r\n    get classList() { return this.panelClass; }\r\n    /**\r\n     * @param {?} classes\r\n     * @return {?}\r\n     */\r\n    set classList(classes) { this.panelClass = classes; }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        this.setPositionClasses();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead();\r\n        this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._tabSubscription.unsubscribe();\r\n        this.closed.complete();\r\n    }\r\n    /**\r\n     * Stream that emits whenever the hovered menu item changes.\r\n     * @return {?}\r\n     */\r\n    _hovered() {\r\n        return this._itemChanges.pipe(startWith(this._items), switchMap(items => merge(...items.map(item => item._hovered))));\r\n    }\r\n    /**\r\n     * Handle a keyboard event from the menu, delegating to the appropriate action.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleKeydown(event) {\r\n        /** @type {?} */\r\n        const keyCode = event.keyCode;\r\n        switch (keyCode) {\r\n            case ESCAPE:\r\n                this.closed.emit('keydown');\r\n                break;\r\n            case LEFT_ARROW:\r\n                if (this.parentMenu && this.direction === 'ltr') {\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            case RIGHT_ARROW:\r\n                if (this.parentMenu && this.direction === 'rtl') {\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            default:\r\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\r\n                    this._keyManager.setFocusOrigin('keyboard');\r\n                }\r\n                this._keyManager.onKeydown(event);\r\n        }\r\n    }\r\n    /**\r\n     * Focus the first item in the menu.\r\n     * @param {?=} origin Action from which the focus originated. Used to set the correct styling.\r\n     * @return {?}\r\n     */\r\n    focusFirstItem(origin = 'program') {\r\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\r\n        if (this.lazyContent) {\r\n            this._ngZone.onStable.asObservable()\r\n                .pipe(take(1))\r\n                .subscribe(() => this._keyManager.setFocusOrigin(origin).setFirstItemActive());\r\n        }\r\n        else {\r\n            this._keyManager.setFocusOrigin(origin).setFirstItemActive();\r\n        }\r\n    }\r\n    /**\r\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\r\n     * the user to start from the first option when pressing the down arrow.\r\n     * @return {?}\r\n     */\r\n    resetActiveItem() {\r\n        this._keyManager.setActiveItem(-1);\r\n    }\r\n    /**\r\n     * Sets the menu panel elevation.\r\n     * @param {?} depth Number of parent menus that come before the menu.\r\n     * @return {?}\r\n     */\r\n    setElevation(depth) {\r\n        /** @type {?} */\r\n        const newElevation = `mat-elevation-z${MAT_MENU_BASE_ELEVATION + depth}`;\r\n        /** @type {?} */\r\n        const customElevation = Object.keys(this._classList).find(c => c.startsWith('mat-elevation-z'));\r\n        if (!customElevation || customElevation === this._previousElevation) {\r\n            if (this._previousElevation) {\r\n                this._classList[this._previousElevation] = false;\r\n            }\r\n            this._classList[newElevation] = true;\r\n            this._previousElevation = newElevation;\r\n        }\r\n    }\r\n    /**\r\n     * Registers a menu item with the menu.\r\n     * \\@docs-private\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    addItem(item) {\r\n        // We register the items through this method, rather than picking them up through\r\n        // `ContentChildren`, because we need the items to be picked up by their closest\r\n        // `mat-menu` ancestor. If we used `@ContentChildren(MatMenuItem, {descendants: true})`,\r\n        // all descendant items will bleed into the top-level menu in the case where the consumer\r\n        // has `mat-menu` instances nested inside each other.\r\n        if (this._items.indexOf(item) === -1) {\r\n            this._items.push(item);\r\n            this._itemChanges.next(this._items);\r\n        }\r\n    }\r\n    /**\r\n     * Removes an item from the menu.\r\n     * \\@docs-private\r\n     * @param {?} item\r\n     * @return {?}\r\n     */\r\n    removeItem(item) {\r\n        /** @type {?} */\r\n        const index = this._items.indexOf(item);\r\n        if (this._items.indexOf(item) > -1) {\r\n            this._items.splice(index, 1);\r\n            this._itemChanges.next(this._items);\r\n        }\r\n    }\r\n    /**\r\n     * Adds classes to the menu panel based on its position. Can be used by\r\n     * consumers to add specific styling based on the position.\r\n     * \\@docs-private\r\n     * @param {?=} posX Position of the menu along the x axis.\r\n     * @param {?=} posY Position of the menu along the y axis.\r\n     * @return {?}\r\n     */\r\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\r\n        /** @type {?} */\r\n        const classes = this._classList;\r\n        classes['mat-menu-before'] = posX === 'before';\r\n        classes['mat-menu-after'] = posX === 'after';\r\n        classes['mat-menu-above'] = posY === 'above';\r\n        classes['mat-menu-below'] = posY === 'below';\r\n    }\r\n    /**\r\n     * Starts the enter animation.\r\n     * @return {?}\r\n     */\r\n    _startAnimation() {\r\n        // @breaking-change 8.0.0 Combine with _resetAnimation.\r\n        this._panelAnimationState = 'enter';\r\n    }\r\n    /**\r\n     * Resets the panel animation to its initial state.\r\n     * @return {?}\r\n     */\r\n    _resetAnimation() {\r\n        // @breaking-change 8.0.0 Combine with _startAnimation.\r\n        this._panelAnimationState = 'void';\r\n    }\r\n    /**\r\n     * Callback that is invoked when the panel animation completes.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _onAnimationDone(event) {\r\n        this._animationDone.next(event);\r\n        this._isAnimating = false;\r\n        // Scroll the content element to the top once the animation is done. This is necessary, because\r\n        // we move focus to the first item while it's still being animated, which can throw the browser\r\n        // off when it determines the scroll position. Alternatively we can move focus when the\r\n        // animation is done, however moving focus asynchronously will interrupt screen readers\r\n        // which are in the process of reading out the menu already. We take the `element` from\r\n        // the `event` since we can't use a `ViewChild` to access the pane.\r\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\r\n            event.element.scrollTop = 0;\r\n        }\r\n    }\r\n}\r\nMatMenu.decorators = [\r\n    { type: Component, args: [{selector: 'mat-menu',\r\n                template: \"<ng-template><div class=\\\"mat-menu-panel\\\" [ngClass]=\\\"_classList\\\" (keydown)=\\\"_handleKeydown($event)\\\" (click)=\\\"closed.emit('click')\\\" [@transformMenu]=\\\"_panelAnimationState\\\" (@transformMenu.start)=\\\"_isAnimating = true\\\" (@transformMenu.done)=\\\"_onAnimationDone($event)\\\" tabindex=\\\"-1\\\" role=\\\"menu\\\"><div class=\\\"mat-menu-content\\\"><ng-content></ng-content></div></div></ng-template>\",\r\n                styles: [\".mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0}@media screen and (-ms-high-contrast:active){.mat-menu-panel{outline:solid 1px}}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:0;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}@media screen and (-ms-high-contrast:active){.mat-menu-item-highlighted,.mat-menu-item.cdk-keyboard-focused,.mat-menu-item.cdk-program-focused{outline:dotted 1px}}.mat-menu-item-submenu-trigger{padding-right:32px}.mat-menu-item-submenu-trigger::after{width:0;height:0;border-style:solid;border-width:5px 0 5px 5px;border-color:transparent transparent transparent currentColor;content:'';display:inline-block;position:absolute;top:50%;right:16px;transform:translateY(-50%)}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}[dir=rtl] .mat-menu-item-submenu-trigger::after{right:auto;left:16px;transform:rotateY(180deg) translateY(-50%)}.mat-menu-panel.ng-animating .mat-menu-item-submenu-trigger{pointer-events:none}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\"],\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                exportAs: 'matMenu',\r\n                animations: [\r\n                    matMenuAnimations.transformMenu,\r\n                    matMenuAnimations.fadeInItems\r\n                ],\r\n                providers: [\r\n                    { provide: MAT_MENU_PANEL, useExisting: MatMenu }\r\n                ]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatMenu.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\r\n];\r\nMatMenu.propDecorators = {\r\n    backdropClass: [{ type: Input }],\r\n    xPosition: [{ type: Input }],\r\n    yPosition: [{ type: Input }],\r\n    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],\r\n    items: [{ type: ContentChildren, args: [MatMenuItem,] }],\r\n    lazyContent: [{ type: ContentChild, args: [MatMenuContent,] }],\r\n    overlapTrigger: [{ type: Input }],\r\n    hasBackdrop: [{ type: Input }],\r\n    panelClass: [{ type: Input, args: ['class',] }],\r\n    classList: [{ type: Input }],\r\n    closed: [{ type: Output }],\r\n    close: [{ type: Output }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n/** *\r\n * Injection token that determines the scroll handling while the menu is open.\r\n  @type {?} */\r\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\r\n/**\r\n * \\@docs-private\r\n * @param {?} overlay\r\n * @return {?}\r\n */\r\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return () => overlay.scrollStrategies.reposition();\r\n}\r\n/** *\r\n * \\@docs-private\r\n  @type {?} */\r\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_MENU_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\r\n};\r\n/** *\r\n * Default top padding of the menu panel.\r\n  @type {?} */\r\nconst MENU_PANEL_TOP_PADDING = 8;\r\n/**\r\n * This directive is intended to be used in conjunction with an mat-menu tag.  It is\r\n * responsible for toggling the display of the provided menu instance.\r\n */\r\nclass MatMenuTrigger {\r\n    /**\r\n     * @param {?} _overlay\r\n     * @param {?} _element\r\n     * @param {?} _viewContainerRef\r\n     * @param {?} scrollStrategy\r\n     * @param {?} _parentMenu\r\n     * @param {?} _menuItemInstance\r\n     * @param {?} _dir\r\n     * @param {?=} _focusMonitor\r\n     */\r\n    constructor(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {\r\n        this._overlay = _overlay;\r\n        this._element = _element;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._parentMenu = _parentMenu;\r\n        this._menuItemInstance = _menuItemInstance;\r\n        this._dir = _dir;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._overlayRef = null;\r\n        this._menuOpen = false;\r\n        this._closeSubscription = Subscription.EMPTY;\r\n        this._hoverSubscription = Subscription.EMPTY;\r\n        // Tracking input type is necessary so it's possible to only auto-focus\r\n        // the first item of the list when the menu is opened via the keyboard\r\n        this._openedBy = null;\r\n        /**\r\n         * Event emitted when the associated menu is opened.\r\n         */\r\n        this.menuOpened = new EventEmitter();\r\n        /**\r\n         * Event emitted when the associated menu is opened.\r\n         * @deprecated Switch to `menuOpened` instead\r\n         * \\@breaking-change 8.0.0\r\n         */\r\n        this.onMenuOpen = this.menuOpened;\r\n        /**\r\n         * Event emitted when the associated menu is closed.\r\n         */\r\n        this.menuClosed = new EventEmitter();\r\n        /**\r\n         * Event emitted when the associated menu is closed.\r\n         * @deprecated Switch to `menuClosed` instead\r\n         * \\@breaking-change 8.0.0\r\n         */\r\n        this.onMenuClose = this.menuClosed;\r\n        if (_menuItemInstance) {\r\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\r\n        }\r\n        this._scrollStrategy = scrollStrategy;\r\n    }\r\n    /**\r\n     * @deprecated\r\n     * \\@breaking-change 8.0.0\r\n     * @return {?}\r\n     */\r\n    get _deprecatedMatMenuTriggerFor() {\r\n        return this.menu;\r\n    }\r\n    /**\r\n     * @param {?} v\r\n     * @return {?}\r\n     */\r\n    set _deprecatedMatMenuTriggerFor(v) {\r\n        this.menu = v;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngAfterContentInit() {\r\n        this._checkMenu();\r\n        this.menu.close.asObservable().subscribe(reason => {\r\n            this._destroyMenu();\r\n            // If a click closed the menu, we should close the entire chain of nested menus.\r\n            if ((reason === 'click' || reason === 'tab') && this._parentMenu) {\r\n                this._parentMenu.closed.emit(reason);\r\n            }\r\n        });\r\n        this._handleHover();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        if (this._overlayRef) {\r\n            this._overlayRef.dispose();\r\n            this._overlayRef = null;\r\n        }\r\n        this._cleanUpSubscriptions();\r\n    }\r\n    /**\r\n     * Whether the menu is open.\r\n     * @return {?}\r\n     */\r\n    get menuOpen() {\r\n        return this._menuOpen;\r\n    }\r\n    /**\r\n     * The text direction of the containing app.\r\n     * @return {?}\r\n     */\r\n    get dir() {\r\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\r\n    }\r\n    /**\r\n     * Whether the menu triggers a sub-menu or a top-level one.\r\n     * @return {?}\r\n     */\r\n    triggersSubmenu() {\r\n        return !!(this._menuItemInstance && this._parentMenu);\r\n    }\r\n    /**\r\n     * Toggles the menu between the open and closed states.\r\n     * @return {?}\r\n     */\r\n    toggleMenu() {\r\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\r\n    }\r\n    /**\r\n     * Opens the menu.\r\n     * @return {?}\r\n     */\r\n    openMenu() {\r\n        if (this._menuOpen) {\r\n            return;\r\n        }\r\n        this._checkMenu();\r\n        /** @type {?} */\r\n        const overlayRef = this._createOverlay();\r\n        this._setPosition(/** @type {?} */ (overlayRef.getConfig().positionStrategy));\r\n        overlayRef.attach(this._portal);\r\n        if (this.menu.lazyContent) {\r\n            this.menu.lazyContent.attach(this.menuData);\r\n        }\r\n        this._closeSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());\r\n        this._initMenu();\r\n        if (this.menu instanceof MatMenu) {\r\n            this.menu._startAnimation();\r\n        }\r\n    }\r\n    /**\r\n     * Closes the menu.\r\n     * @return {?}\r\n     */\r\n    closeMenu() {\r\n        this.menu.close.emit();\r\n    }\r\n    /**\r\n     * Focuses the menu trigger.\r\n     * @param {?=} origin Source of the menu trigger's focus.\r\n     * @return {?}\r\n     */\r\n    focus(origin = 'program') {\r\n        if (this._focusMonitor) {\r\n            this._focusMonitor.focusVia(this._element, origin);\r\n        }\r\n        else {\r\n            this._element.nativeElement.focus();\r\n        }\r\n    }\r\n    /**\r\n     * Closes the menu and does the necessary cleanup.\r\n     * @return {?}\r\n     */\r\n    _destroyMenu() {\r\n        if (!this._overlayRef || !this.menuOpen) {\r\n            return;\r\n        }\r\n        /** @type {?} */\r\n        const menu = this.menu;\r\n        this._closeSubscription.unsubscribe();\r\n        this._overlayRef.detach();\r\n        if (menu instanceof MatMenu) {\r\n            menu._resetAnimation();\r\n            if (menu.lazyContent) {\r\n                // Wait for the exit animation to finish before detaching the content.\r\n                menu._animationDone\r\n                    .pipe(filter(event => event.toState === 'void'), take(1), \r\n                // Interrupt if the content got re-attached.\r\n                takeUntil(menu.lazyContent._attached))\r\n                    .subscribe(() => /** @type {?} */ ((menu.lazyContent)).detach(), undefined, () => {\r\n                    // No matter whether the content got re-attached, reset the menu.\r\n                    this._resetMenu();\r\n                });\r\n            }\r\n            else {\r\n                this._resetMenu();\r\n            }\r\n        }\r\n        else {\r\n            this._resetMenu();\r\n            if (menu.lazyContent) {\r\n                menu.lazyContent.detach();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * This method sets the menu state to open and focuses the first item if\r\n     * the menu was opened via the keyboard.\r\n     * @return {?}\r\n     */\r\n    _initMenu() {\r\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMenu : undefined;\r\n        this.menu.direction = this.dir;\r\n        this._setMenuElevation();\r\n        this._setIsMenuOpen(true);\r\n        this.menu.focusFirstItem(this._openedBy || 'program');\r\n    }\r\n    /**\r\n     * Updates the menu elevation based on the amount of parent menus that it has.\r\n     * @return {?}\r\n     */\r\n    _setMenuElevation() {\r\n        if (this.menu.setElevation) {\r\n            /** @type {?} */\r\n            let depth = 0;\r\n            /** @type {?} */\r\n            let parentMenu = this.menu.parentMenu;\r\n            while (parentMenu) {\r\n                depth++;\r\n                parentMenu = parentMenu.parentMenu;\r\n            }\r\n            this.menu.setElevation(depth);\r\n        }\r\n    }\r\n    /**\r\n     * This method resets the menu when it's closed, most importantly restoring\r\n     * focus to the menu trigger if the menu was opened via the keyboard.\r\n     * @return {?}\r\n     */\r\n    _resetMenu() {\r\n        this._setIsMenuOpen(false);\r\n        // We should reset focus if the user is navigating using a keyboard or\r\n        // if we have a top-level trigger which might cause focus to be lost\r\n        // when clicking on the backdrop.\r\n        if (!this._openedBy) {\r\n            // Note that the focus style will show up both for `program` and\r\n            // `keyboard` so we don't have to specify which one it is.\r\n            this.focus();\r\n        }\r\n        else if (!this.triggersSubmenu()) {\r\n            this.focus(this._openedBy);\r\n        }\r\n        this._openedBy = null;\r\n    }\r\n    /**\r\n     * @param {?} isOpen\r\n     * @return {?}\r\n     */\r\n    _setIsMenuOpen(isOpen) {\r\n        this._menuOpen = isOpen;\r\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\r\n        if (this.triggersSubmenu()) {\r\n            this._menuItemInstance._highlighted = isOpen;\r\n        }\r\n    }\r\n    /**\r\n     * This method checks that a valid instance of MatMenu has been passed into\r\n     * matMenuTriggerFor. If not, an exception is thrown.\r\n     * @return {?}\r\n     */\r\n    _checkMenu() {\r\n        if (!this.menu) {\r\n            throwMatMenuMissingError();\r\n        }\r\n    }\r\n    /**\r\n     * This method creates the overlay from the provided menu's template and saves its\r\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\r\n     * @return {?}\r\n     */\r\n    _createOverlay() {\r\n        if (!this._overlayRef) {\r\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\r\n            /** @type {?} */\r\n            const config = this._getOverlayConfig();\r\n            this._subscribeToPositions(/** @type {?} */ (config.positionStrategy));\r\n            this._overlayRef = this._overlay.create(config);\r\n            // Consume the `keydownEvents` in order to prevent them from going to another overlay.\r\n            // Ideally we'd also have our keyboard event logic in here, however doing so will\r\n            // break anybody that may have implemented the `MatMenuPanel` themselves.\r\n            this._overlayRef.keydownEvents().subscribe();\r\n        }\r\n        return this._overlayRef;\r\n    }\r\n    /**\r\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\r\n     * @return {?} OverlayConfig\r\n     */\r\n    _getOverlayConfig() {\r\n        return new OverlayConfig({\r\n            positionStrategy: this._overlay.position()\r\n                .flexibleConnectedTo(this._element)\r\n                .withLockedPosition()\r\n                .withTransformOriginOn('.mat-menu-panel'),\r\n            hasBackdrop: this.menu.hasBackdrop == null ? !this.triggersSubmenu() : this.menu.hasBackdrop,\r\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\r\n            scrollStrategy: this._scrollStrategy(),\r\n            direction: this._dir\r\n        });\r\n    }\r\n    /**\r\n     * Listens to changes in the position of the overlay and sets the correct classes\r\n     * on the menu based on the new position. This ensures the animation origin is always\r\n     * correct, even if a fallback position is used for the overlay.\r\n     * @param {?} position\r\n     * @return {?}\r\n     */\r\n    _subscribeToPositions(position) {\r\n        if (this.menu.setPositionClasses) {\r\n            position.positionChanges.subscribe(change => {\r\n                /** @type {?} */\r\n                const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\r\n                /** @type {?} */\r\n                const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above'; /** @type {?} */\r\n                ((this.menu.setPositionClasses))(posX, posY);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Sets the appropriate positions on a position strategy\r\n     * so the overlay connects with the trigger correctly.\r\n     * @param {?} positionStrategy Strategy whose position to update.\r\n     * @return {?}\r\n     */\r\n    _setPosition(positionStrategy) {\r\n        let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\r\n        let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\r\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\r\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\r\n        /** @type {?} */\r\n        let offsetY = 0;\r\n        if (this.triggersSubmenu()) {\r\n            // When the menu is a sub-menu, it should always align itself\r\n            // to the edges of the trigger, instead of overlapping it.\r\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\r\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\r\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\r\n        }\r\n        else if (!this.menu.overlapTrigger) {\r\n            originY = overlayY === 'top' ? 'bottom' : 'top';\r\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\r\n        }\r\n        positionStrategy.withPositions([\r\n            { originX, originY, overlayX, overlayY, offsetY },\r\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\r\n            {\r\n                originX,\r\n                originY: originFallbackY,\r\n                overlayX,\r\n                overlayY: overlayFallbackY,\r\n                offsetY: -offsetY\r\n            },\r\n            {\r\n                originX: originFallbackX,\r\n                originY: originFallbackY,\r\n                overlayX: overlayFallbackX,\r\n                overlayY: overlayFallbackY,\r\n                offsetY: -offsetY\r\n            }\r\n        ]);\r\n    }\r\n    /**\r\n     * Cleans up the active subscriptions.\r\n     * @return {?}\r\n     */\r\n    _cleanUpSubscriptions() {\r\n        this._closeSubscription.unsubscribe();\r\n        this._hoverSubscription.unsubscribe();\r\n    }\r\n    /**\r\n     * Returns a stream that emits whenever an action that should close the menu occurs.\r\n     * @return {?}\r\n     */\r\n    _menuClosingActions() {\r\n        /** @type {?} */\r\n        const backdrop = /** @type {?} */ ((this._overlayRef)).backdropClick();\r\n        /** @type {?} */\r\n        const detachments = /** @type {?} */ ((this._overlayRef)).detachments();\r\n        /** @type {?} */\r\n        const parentClose = this._parentMenu ? this._parentMenu.closed : of();\r\n        /** @type {?} */\r\n        const hover = this._parentMenu ? this._parentMenu._hovered().pipe(filter(active => active !== this._menuItemInstance), filter(() => this._menuOpen)) : of();\r\n        return merge(backdrop, parentClose, hover, detachments);\r\n    }\r\n    /**\r\n     * Handles mouse presses on the trigger.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleMousedown(event) {\r\n        if (!isFakeMousedownFromScreenReader(event)) {\r\n            // Since right or middle button clicks won't trigger the `click` event,\r\n            // we shouldn't consider the menu as opened by mouse in those cases.\r\n            this._openedBy = event.button === 0 ? 'mouse' : null;\r\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\r\n            // we should prevent focus from moving onto it via click to avoid the\r\n            // highlight from lingering on the menu item.\r\n            if (this.triggersSubmenu()) {\r\n                event.preventDefault();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Handles key presses on the trigger.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleKeydown(event) {\r\n        /** @type {?} */\r\n        const keyCode = event.keyCode;\r\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\r\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\r\n            this.openMenu();\r\n        }\r\n    }\r\n    /**\r\n     * Handles click events on the trigger.\r\n     * @param {?} event\r\n     * @return {?}\r\n     */\r\n    _handleClick(event) {\r\n        if (this.triggersSubmenu()) {\r\n            // Stop event propagation to avoid closing the parent menu.\r\n            event.stopPropagation();\r\n            this.openMenu();\r\n        }\r\n        else {\r\n            this.toggleMenu();\r\n        }\r\n    }\r\n    /**\r\n     * Handles the cases where the user hovers over the trigger.\r\n     * @return {?}\r\n     */\r\n    _handleHover() {\r\n        // Subscribe to changes in the hovered item in order to toggle the panel.\r\n        if (!this.triggersSubmenu()) {\r\n            return;\r\n        }\r\n        this._hoverSubscription = this._parentMenu._hovered()\r\n            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\r\n            // with different data and triggers), we have to delay it by a tick to ensure that\r\n            // it won't be closed immediately after it is opened.\r\n            .pipe(filter(active => active === this._menuItemInstance && !active.disabled), delay(0, asapScheduler))\r\n            .subscribe(() => {\r\n            this._openedBy = 'mouse';\r\n            // If the same menu is used between multiple triggers, it might still be animating\r\n            // while the new trigger tries to re-open it. Wait for the animation to finish\r\n            // before doing so. Also interrupt if the user moves to another item.\r\n            if (this.menu instanceof MatMenu && this.menu._isAnimating) {\r\n                // We need the `delay(0)` here in order to avoid\r\n                // 'changed after checked' errors in some cases. See #12194.\r\n                this.menu._animationDone\r\n                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))\r\n                    .subscribe(() => this.openMenu());\r\n            }\r\n            else {\r\n                this.openMenu();\r\n            }\r\n        });\r\n    }\r\n}\r\nMatMenuTrigger.decorators = [\r\n    { type: Directive, args: [{\r\n                selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\r\n                host: {\r\n                    'aria-haspopup': 'true',\r\n                    '[attr.aria-expanded]': 'menuOpen || null',\r\n                    '(mousedown)': '_handleMousedown($event)',\r\n                    '(touchstart)': '_openedBy = \"touch\"',\r\n                    '(keydown)': '_handleKeydown($event)',\r\n                    '(click)': '_handleClick($event)',\r\n                },\r\n                exportAs: 'matMenuTrigger'\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nMatMenuTrigger.ctorParameters = () => [\r\n    { type: Overlay },\r\n    { type: ElementRef },\r\n    { type: ViewContainerRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },\r\n    { type: MatMenu, decorators: [{ type: Optional }] },\r\n    { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: FocusMonitor }\r\n];\r\nMatMenuTrigger.propDecorators = {\r\n    _deprecatedMatMenuTriggerFor: [{ type: Input, args: ['mat-menu-trigger-for',] }],\r\n    menu: [{ type: Input, args: ['matMenuTriggerFor',] }],\r\n    menuData: [{ type: Input, args: ['matMenuTriggerData',] }],\r\n    menuOpened: [{ type: Output }],\r\n    onMenuOpen: [{ type: Output }],\r\n    menuClosed: [{ type: Output }],\r\n    onMenuClose: [{ type: Output }]\r\n};\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\nclass MatMenuModule {\r\n}\r\nMatMenuModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    MatCommonModule,\r\n                    MatRippleModule,\r\n                    OverlayModule,\r\n                ],\r\n                exports: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent, MatCommonModule],\r\n                declarations: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent],\r\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\r\n            },] },\r\n];\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n\r\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\r\n */\r\n\r\nexport { MAT_MENU_SCROLL_STRATEGY, MatMenuModule, MatMenu, MAT_MENU_DEFAULT_OPTIONS, MatMenuItem, MatMenuTrigger, matMenuAnimations, fadeInItems, transformMenu, MatMenuContent, MAT_MENU_DEFAULT_OPTIONS_FACTORY as ɵa21, MatMenuItemBase as ɵb21, _MatMenuItemMixinBase as ɵc21, MAT_MENU_PANEL as ɵf21, MAT_MENU_SCROLL_STRATEGY_FACTORY as ɵd21, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as ɵe21 };\r\n\r\n"]}